---
sidebar_position: 6
---

# 5.4 Modbus协议细节

### 5.4.1 Modbus协议概述

简而言之,Modbus 协议是一种单主/多从的通信协议,其特点是在同一时间总线上只能有一个主设备,但可以有一个或者多个(最多 247 个)从设备。Modbus通信总是由主设备发起,当从设备没有收到来自主设备的请求时，从设备不会主动发送数据。从设备之间不能相互通信,主设备只能同时启动一个 Modbus 访回事务处理。 主设备可以采用两种方式向从设备发送 Modbus 请求报文，即主设备可以对指定的单个从设备或者线路上所有的从设备发送请求报文，而从设备只能在被被动接收请求报文后给出响应报文，即应答。这两种模式分别如下图所示：

**Modbus请求应答周期**

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image31.png) 

单播模式。主设备仅仅寻址单个从设备,从设备接收并处理请求后,向主设备返回一个响应报文,即应答。在这种模式下,一个 Modbus 事务处理包含两个报文:一个是主设备的请求报文,另一个是从设备的响应报文。

每个从设备必须有唯一的地址(地址范围为 1~247),这样才能区别于其它从设备,从而可以独立被寻址，同时主设备不占用地址。

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image32.png) 

广播模式。此种模式下,主设备可以向所有从设备发送请求指令，而从设备在接收到广播指令后仅进行相关指令的事务处理，而不要求返回应答。因此广播模式下,请求指令必须是 Modbus 标准功能中的写指令。

根据 Modbus 标准协议的要求,所有从设备必须接收广播模式下的写指令，且地址0被保留,用来识别广播通信

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image33.png) 

- 请求：

  主设备发送的请求报文主要包括从设备地址（或广播地址0）、功能码、传输的数据以及差错检测字段。

  查询消息中的功能码告诉我们被选中的从设备地址要执行何种功能。数据段包含从设备要执行功能的所有附加信息。例如,功能代码 03 要求从设备读取保持寄存器并返回其内容。

数据段必须包含要告诉从设备的信息:从哪个寄存器开始读取及要读取的寄存器数量。差错检测域为从设备提供一种验证消息内容是否正确的方法。

- 应答：

  从设备的应答报文包括地址、功能码、差错检测域等； 如果从设备产生了一个正常的回应,则回应消息中的功能码是查询消息中的功能码的回应。数据段包括从设备收集的数据,如寄存器值或状态。如果有错误发生,则功能码将被修改以用于指出回应消息是错误的，同时数据段包含描述此错误信息的代码。差错检测域允许主设备确认消息内容是否可用。

对于串行链路来说，又存在两种传输模式:ASCII(American StandardCode for Information Interchange,美国标准信息交换码)模式和 RTU(RemoteTerminal Unit，远程终端单元)模式。但是,对于同一网络或链路来说，所有设备必须保持统一,要么统一为 ASCII 模式,要么统一为 RTU 模式,不可共存。相对来说,RTU模式的传输效率更高,因此在当前普遍的生产环境中,RTU 模式获得了广泛应用,而 ASCII模式只能作为特殊情况下的可选项。

### 5.4.2 Modbus寄存器（存储区）

Modbus 协议中的一个重要概念是寄存器,所有数据均存放于寄存器。最初，Modbus 协议借鉴了 PLC 中寄存器的含义，但是随着 Modbus 协议的广泛应用，寄存器的概念进一步泛化,它不再是指具体的物理寄存器,也可能是指一块内存区域Modbus 寄存器根据存放的数据类型以及各自的读写特性将寄存器分为四部分，这四部分既可以连续,也可以不连续,由开发者决定。寄存器意义如下表所示：

Modbus寄存器（存储区）

| 寄存器种类                   | 说明                                                         | 与PLC类比      | 举例说明                                                     |
| ---------------------------- | ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ |
| 线圈状态(Coil Status)        | 输出端口。可设定端口输出状态，也可以读取该位的输出状态。可分为两种不同的执行状态，列如保持型或边沿触发型 | DO(数字量输出) | 电磁阀输出、MOSFEF输出、LED显示等                            |
| 离散输入状态(Input Status)   | 输入端口。通过外部设定改变输入状态，可读但不可以写           | DI(数字量输入) | 拨码开关、接近开关等                                         |
| 保持寄存器(Holding Register) | 输出参数或保持参数，控制器运行时被设定的某些参数，可读可写   | AO(模拟量输出) | 模拟量输出设定值，PID运行参数，变量阀输出大小，传感器报警上限下限 |
| 输入寄存器                   | 输入参数。控制器运行时从外部设备获得的参数，但可读不可写     | AI(模拟量输入) | 模拟量输入                                                   |

（PLC）数据的传输离不开存储和读写操作，为了更好存储不同的数据类型，我们可以理解Modbus 会将布尔和非布尔的数据分开存储。

#### 1. 存储区类型

我们可以将存储区类型分为布尔类型和非布尔类型，布尔类型我们用线圈（Coil）表示，非布尔用寄存器（Register）表示；

- **什么是布尔？**

  - 布尔类型只有两个值，false 和 true。
  - 通常用来判断条件是否成立。
  - C语言语法规定，如果变量值为 0 就是 false，否则为 true,布尔变量只有这两个值。

因此，我们便有了线圈和寄存器的概念；

- **那线圈和寄存器又是什么？**
- **线圈：** 从电气角度来看，在电气控制回路中，一般都是靠接触器或中间继电器来实现控制，接触器或中继最终靠的是线圈的得电和失电来控制触点闭合和断开，因此用线圈表示布尔量；
  - **寄存器：** 用来暂时存放参与运算的数据和运算结果，具有接收数据、存放数据和输出数据的功能。
  - 而寄存器在计算机中，就是用来存储数据的，因此非布尔的数据放在寄存器里。

回到存储区分类，目的就是: 更好地存储和区分不同的数据类型。

Modbus的线圈和寄存器应该也按照只读、读写来进一步划分，因此这就形成了Modbus的存储区，如下表所示：

- **Modbus存储区类型及名称**

| 序号 | 读写 | 存储类型 | 存储区名称 |
| ---- | ---- | -------- | ---------- |
| 1    | 只读 | 线圈     | 输入线圈   |
| 2    | 读写 | 线圈     | 输出线圈   |
| 3    | 只读 | 寄存器   | 输入寄存器 |
| 4    | 读写 | 寄存器   | 保持寄存器 |

- **存储区代号：**

为什么需要存储区代号？上面表格里的存储区名称是一个全称，开发和使用中使用全称会比较麻烦，因此需要给他们取个别名。所以Modbus也要给这些存储区取一个代号，干脆直接用数字吧，于是，就有了下面的规定：

| 存储区名称 | 存储区代号 |
| ---------- | ---------- |
| 输入线圈   | 1区        |
| 输出线圈   | 0区        |
| 输入寄存器 | 3区        |
| 保持寄存器 | 4区        |

存储区代号其实可以简单理解为我们的名字，例如我们的名字有全名，和小名，全名呢是正式场合，外人叫的，小名呢是我们的亲近的人，日常场合叫的。这么一说是不是就理解为什么有存储区代号啦。

- **存储区范围：**
  - 无论是什么存储区，都会有一个范围的限制；Modbus的每个存储区也规定了一个范围，不能无限制使用。
  - Modbus规定每个存储区的最大范围是65536，也就是0~65535。

#### 2. 协议地址模型

PLC地址是我们常见的，但它是怎么组成的的，它是由存储区代号 + 地址组成，我们把这样的地址称为绝对地址，把后面的地址成为相对地址；而我们的Modbus地址跟PLC地址也是类似的；

Modbus地址公式：存储区代号 + （地址 + 1）如下表所示：

- **Modbus长地址模型**

| 存储区名称 | 存储区代号 | 绝对地址范围  | 相对地址范围 |
| ---------- | ---------- | ------------- | ------------ |
| 输入线圈   | 1区        | 100001~165536 | 0~65535      |
| 输出线圈   | 0区        | 000001~065536 | 0~65535      |
| 输入寄存器 | 3区        | 300001~365536 | 0~65535      |
| 保持寄存器 | 4区        | 400001~465536 | 0~65535      |

Modbus地址分为长地址模型和短地址模型，上面Modbus长地址模型，但是在实际使用中，我们一般用不了这么多地址，一般情况下，10000以内就已经足够使用了；因此，为了方便我们便有了另一种短的地址模型，如下图所示：

- **Modbus短地址模型**

| 存储区名称 | 存储区代号 | 绝对地址范围 | 相对地址范围 |
| ---------- | ---------- | ------------ | ------------ |
| 输入线圈   | 1区        | 10001~19999  | 0~9998       |
| 输出线圈   | 0区        | 00001~09999  | 0~9998       |
| 输入寄存器 | 3区        | 30001~39999  | 0~9998       |
| 保持寄存器 | 4区        | 40001~49999  | 0~9998       |

### 5.4.3 Modbus常用功能码

Modbus功能码占用1字节，取值范围是1127。之所以127以上不能用，是因为Modbus规定当出现异常时，功能码+0x80（十进制128）代表异常状态，因此129（1+128）255（127+128）的取值代表异常码。

- **Modbus常用功能码**

| 功能码  | 描述                           | 寄存器PLC地址 | 位/字操作 | 操作数量   |
| ------- | ------------------------------ | ------------- | --------- | ---------- |
| 01H     | 读线圈寄存器（读输出线圈）     | 00001~09999   | 位操作    | 单个或多个 |
| 02H     | 读离散输入寄存器（读输入线圈） | 10001~19999   | 位操作    | 单个或多个 |
| 03H     | 读保持寄存器                   | 40001~49999   | 字操作    | 单个或多个 |
| 04H     | 读输入寄存器                   | 30001~39999   | 字操作    | 单个或多个 |
| 05H     | 写单个线圈寄存器               | 00001~09999   | 位操作    | 单个       |
| 06H     | 写单个保持寄存器               | 40001~49999   | 字操作    | 单个       |
| 0FH(15) | 写多个线圈寄存器               | 00001~09999   | 位操作    | 多个       |
| 10H(16) | 写多个保持寄存器               | 40001~49999   | 字操作    | 多个       |

功能码可以分为位操作和字操作两类。位操作的最小为1位（bit）,字操作的最小单位为2字节。

① 位操作指令：读取线圈状态的功能码 01 ，读（离散）输入状态功能码 02 ，写单个线圈功能码 05 和写多个线圈功能码 15。
② 字操作指令：读保持寄存器功能码 03 ，读输入寄存器功能码 04 ，写单个保持寄存器功能码 06 ,写多个保持寄存器功能码 16 。

### 5.4.4 Modbus协议类型

Modbus可以在各种介质上传输，那么他的传输模式也分为三种。包括ASCII、RTU(远程终端控制系统)、TCP三种报文类型

- **常用Modbus协议**

| Modbus协议    | Modbus协议               |
| ------------- | ------------------------ |
| Modbus RTU    | Modbus RTU Over TCP/IP   |
| Modbus ASCII  | Modbus ASCI Over TCP/IP  |
| Modbus TCP/IP | Modbus RTU Over UDP/IP   |
| Modbus UDP/IP | Modbus ASCII Over UDP/IP |

Modbus协议使用串口传输时可以选择RTU或ASCII模式，并规定了消息、数据结构、命令和应答方式并需要对数据进行校验。ASCII 模式采用LRC校验，RTU模式采用16 位CRC校验。通过以太网传输时使用TCP，这种模式不使用校验，因为TCP协议是一个面向连接的可靠协议。

### 5.4.5  Modbus报文帧

一个报文就是一帧数据，一个数据帧就一个报文： 指的是一串完整的指令数据，本质就是一串数据。

Modbus报文是指主机发送给从机的一帧数据，其中包含着从机的地址，主机想执行的操作，校验码等内容

#### 1.  Modbus ASCII 模式

当控制器设为在Modbus网络上以ASCII模式通信时,在消息中每个8位(b)字节都将作为两个 ASCII字符发送。这种方式的主要优点是字符发送的时间可隔可达到 1秒且不产生错误。 

在ASCII模式下,消息以冒号(:)字符(ASCII码为 0x3A)开始，以回车换行奇结束(ASCII码为 0x0D、0x0A)。消息的其他字段(域)可以使用的传输字符是十六进制的0···9、A···F。处于网络上的 Modbus 设备不断侦测“：”字符,当接收到一个冒号时,每个设备进入解码阶段,并解码下一个字段(地址域)以判断是否是发给自己的。消息帧中的字符间发送的时间间隔最长不能超过 1秒,否则接收设备将认为发生传输错误。 

**下表是一个典型的ASCII报文格式：**

| 开始字符  | 地址  | 功能码 | 数据  | LRC校验 | 结束字符 |
| --------- | ----- | ------ | ----- | ------- | -------- |
| 1byte (:) | 2byte | 2byte  | Nbyte | 2byte   | CR、LF   |

#### 2. Modbus RTU 模式

**Modbus协议RTU报文格式如下所示：**

| 从机地址 | 功能码 | 数据  | CRC校验 |
| -------- | ------ | ----- | ------- |
| 1byte    | 1byte  | Nbyte | 2byte   |

- 帧结构 = 从机地址 + 功能码 + 数据 + 校验 
  - 从机地址: 每个从机都有唯一地址，占用一个字节,范围0-255,其中有效范围是1-247,其中255是广播地址(广播就是对所有从机发送应答)
  - 功能码: 占用一个字节,功能码的意义就是,知道这个指令是干啥的,比如你可以查询从机的数据,也可以修改从机的数据,所以不同功能码对应不同功能.
  - 数据: 根据功能码不同,有不同功能，比方说功能码是查询从机的数据，这里就是查询数据的地址和查询字节数等。
  - 校验: 在数据传输过程中可能数据会发生错误，CRC检验检测接收的数据是否正确

#### 3. 串行报文帧总结：

ModbusASCII有开始字符(和结束字符(CR LF)，可以作为一帧数据开始和结束的标志，而ModbusRTU没有这样的标志，需要用时间间隔来判断一帧报文的开始和结束，协议规定的时间为3.5个字符周期，就是说一帧报文开始前，必须有大于3.5个字符周期的空闲时间，一帧报文结束后，也必须要有3.5个字符周期的空闲时间否则就会出现粘包的情况。

注意：针对3.5个字符周期，其实是一个具体时间，但是这个时间跟波特率相关。 在串口通信中，1个字符包括1位起始位、8位数据位（一般情况）、1位校验位（或者没有）、1位停止位（一般情况下），因此1个字符包括11个位，那么3.5个字符就是38.5个位，波特率表示的含义是每秒传输的二进制位的个位，因此如果是9600波特率，3.5个字符周期=38.5/9600=0.00401s*1000=4.01ms

### 5.4.6 Modbus 差错校验

在Modbus串行通信中，根据传输模式（ASCII或RTU）的不同，差错校验域将采用不同的校验方法。

- ASCII模式

  在ASCII模式中,报文包含一个错误校验字段,该字段由两个字符组成,其基于对全部报文内容执行的纵向冗余校验(Longitudinal Redundancy ChedLRC)计算的结果而来,计算对象不包括起始的冒号(:)和回车换行符号(CR LF)。

- RTU模式 

  在RTU模式中,报文同样包含一个错误校验字段。与ASCII模式不同的是该字段由 16 个比特位共2字节组成,其值基于对全部报文内容执行的循环冗余校验(Cyclical Redundancy Check,CRC)计算的结果而来,计算对象包括校验域之的所有字节。

#### 1. LRC校验

在ASCII模式中，消息是由特定的字符作为帧头和帧尾分隔的。

一条消息必须以“冒号”(:)字符(ASCII码为0x3A)开始，以“回车换行(CRLF)(ASCII码为 0x0D 和 0x0A)结束。LRC 校验算法的计算范围为“:” “CRLF”之间的字符。

从算法本质来说,LRC域自身为1字节,即包含一个 8位二进制数据,由发送设备通过LRC算法把计算值附到信息末尾。接收设备在接收信息时通过 LRC法重新计算值,并把计算值与 LRC 字段中接收的实际值进行比较。若两者不同，则产生一个错误，返回一个异常响应帧，即对报文中的所有相邻的两个 8位字相加,丢弃任何进位,然后对结果进行二进制补码,计算出 LRC值。

必须注意的是,计算 LRC 校验码的时机是在对报文中每个原始字节进行ASCII码编码之前，对每个原始字节进行LRC校验的计算操作。

- **LRC校验流程：**
  - 将消息中的全部字节相加(不包括起始“:”和结束符(CRLF),并把结果送入8位数据区，舍弃进位。
  - 由0xFF(即全 1)减去最终的数据值,产生1的补码(即二进制反码)
  - 加1产生二进制补码。

以上产生的LRC值占用1字节,但实际上在通过串行链路由ASCII模式传递消息顿时,LRC的结果(1字节)被编码为2字节的ASCII字符,并将其放置在ASCII模式报文帧的CRLF字段之前。

Modbus 标准协议的英文版提供了 LRC算法，其中的参数意义如下unsigned char*auchMsg:含有生成LRC所使用的二进制数据的报文缓存区指针。 unsigned short usDataLen：报文缓存区中的字节数。

**LCR的代码如下：**

```c
/*函数返回unsigned char类型的 LRC值*/

static unsigned char LRC(unsigned char * auchMsg, unsigned short usDatalen)

{

  unsigned char uchLRC=0;       /*LRC字节初始化*/

 

  while(usDataLen--)          /*遍历报文缓冲区*/

    uchLRC+=*auchMsg++;       /*缓冲区宇节相加，自动舍弃进位*/

  

return ((unsigned char)(-(( char)uchLRC))); /*返回二进制补码*/

}
```

下面举一个简单的例子。假设从设备地址为 1,要求读取输人寄存器地址30001的值,则具体的查询消息帧如下:

```c
"：" , "0" , "1" , "0" , "4" , "0" ,"0" ,"0" ,"0" ,"0" ,"0" ,"0" , "1" , "F" , "A" ,CR/LF
```

其中,“F”, “A”即为LRC值在 ASCII模式下的形式，即0xFA.

#### 2. CRC校验

在Modbus RTU传输模式下，通信报文（帧）包括一个基于循环冗余校验方法的差错校验字段。

Modbus协议采用了CRC-16标准校验方法。在RTU模式下，CRC自身由2字节组成，即CRC是一个16位的值。CRC字段校验整个报文的内容，无论报文中的单个字节采用何种奇偶校验方式，整个通信报文均可使用CRC-16校验算法，CRC字段作为报文的最后字段添加在整个报文末尾。

需要注意的是，因为CRC-16是由2字节组成，所以涉及哪个字节放在前面，哪个字节放在后面传输的问题，即大小端模式的选择问题。另外，由于Modbus协议规定寄存器为16位（即2字节）长度，因此大小端问题的存在给很多初学者造成了困扰，下一章我们会重点讲一下大小端的问题。

- **CRC校验流程：**
  - 预置一个16位寄存器为0xFFFF（全1），称之为CRC寄存器。
  - 把数据帧中的第一个字节的8位与CRC寄存器中的低字节进行异或运算，结果存回CRC寄存器。
  - 将CRC寄存器向右移一位，最高位填以0，最低位移出并检测是0还是1。
  - 如果最低位为0：重复第三步（再次右移一位）；如果最低位为1：将CRC寄存器与一个预设的固定值（0xA001）进行异或运算。
  - 重复第三步和第四步直到8次移位。这样处理完了一个完整的八位。
  - 重复第2步到第5步来处理下一个八位，直到所有的字节处理结束。
  - 将该通信消息帧的所有字节按上述步骤计算完成后，再将得到的16位CRC寄存器的高、低位字节进行交换，即发送时首先添加低位字节，然后添加高位字节。
  - 最终CRC寄存器的值就是CRC的校验码。

需要注意的是，在进行CRC计算时只有串行链路上的每个字符的8个数据位参与计算，从而起始位、停止位、奇偶校验位等都不参与CRC计算。

常用的CRC-16算法有查表法、计算法。

**查表法：**

CRC查表法是将位移异或的计算结果做成了一个表，即将0~256 放入一个度为16位的寄存器的低8位,高8位填充0，然后将该寄存器与多项式0xA001照上述步骤3、4直到8 位全部移出，最后寄存器中的值就是表格中的数据，高8位、低 8 位分别单独做成一个表。 实际上,Modbus 标准协议的英文版提供了CRC 查表算法 函数的输入参数意义如下:

```c
unsigned char * puchMsg;         /*要进行CRC校验的消息*/

unsigned short usDataLen;      /*消息中的字节数*/

/*函数返回 unsigned short(即2个字节)类型的 CRC值*/

unsigned short CRC16(unsigned char *puchMsg，unsigned short usDataLen)

{

  unsigned charuchCRCHi=0xFF;         /*高 CRC字节初始化* /

  unsigned char uchCRCLo=0xFF;         /*低 CRC字节初始化*/

  unsigned short uIndex;            /*CRC 循环表中的索引*/

  

  while (usDataLen--)             /* 循环处理传输缓冲区消息 */

  {

    uIndex=uchCRCHi ^ * puchMsg++;        /*计算 CRC* /

    uchCRCHi=uchCRCLo ^ auchCRCHi[uIndex];

    uchCRCLo=auchCRCLo[uIndex];

  }

  return (uchCRCHi <<81uchCRCLo);

}
```

其中，auchCRCHi和auchCRCLo的定义分别如下：

```c
static unsigned char auchcRCHi[] = 

{

  0x00,0xC1,0x81,0x48,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,

  0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,

  0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01，

  0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x01，

  0x00,0xc1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81，

  0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,

  0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01，

  0xc0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,

  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,

  0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,

  0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xCl,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,

  0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41，

  0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,

  0x40,0x01,0xc0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01.0xC0，

  0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,

  0xc0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41，

  0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xC1,0x81,

  0x40

};
```

 

```c
static char auchCRCLo[]=

{

  0x00,0xc0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,

  0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,

  0x08,0xc8,0xDB,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0XDE,0XDE,0x1F,0xDD,

  0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,

  0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xE3,0xE2,0x32,0x36,0xF6,0xF7,

  0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,

  0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,

  0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,

  0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,

  0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,

  0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xAB,0x68,0x78,0xB8,0xB9,0x79,0xBB,

  0x7B,0x7A,0xBA,0xBE,0x7E,0x7E,0xBE,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5，

  0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91，

  0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C，

  0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88，

  0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8E,0x4F,0x8D,0x4D,0x4C,0x8C，

  0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,

  0x40

};
```

注意：实际编程时，auchcRCHi[]和auchCRCLo[]的定义应该放在函数CRC-16()之前。

查表法可以进一步化简如下：

```c
unsigned short CRC16(unsigned char * puchMsg,unsigned short usDataLen)

{

  static const unsigned short usCRCTable[]=

  {

    0x0000,0xC0C1,0xC181,0x0140,0XC301,0X03C0,0X0280,0xc241,

    0XC601,0X06C0,0x0780,0XC741,0X0500,0XC5C1,0XC481,0X0440,

    0xCC01,0X0CC0,0X0D80,0XCD41,0X0F00,0XCEC1,0XCE81,0X0E40,

    0X0A00,0XCAC1,0XCB81,0X0B40,0XC901,0X09C0,0X0880,0XC841,

    0XD801,0x18c0,0X1980,0XD941,0X1B00,0XDBC1,0XDA81,0X1A40,

    0X1E00,0XDEC1,0XDF81,0X1F40,0XDD01,0X1DC0,0X1C80,0XDC41,

    0x1400,0XD4C1,0XD581,0X1540,0XD701,0X17C0,0X1680,0XD641,

    0XD201,0X12c0,0X1380,0XD341,0X1100,0XD1C1,0XD081,0X1040,

    0XF001,0X30C0,0X3180,0XE141,0X3300,0XE3C1,0XE281,0X3240,

    0X3600,0XF6C1,0XE781,0X3740,0XE501,0X35C0,0X3480,0XE441,

    0X3C00,0XFCC1,0XFD81,0X3D40,0XFF01,0X3FC0,0X3EB0,0XFE41,

    0XFA01,0X3AC0,0X3B80,0XFB41,0X3900,0XE9C1,0XF881,0X3840,

    0X2800,0XE8C1,0XE981,0X2940,0XEB01,0X2BC0,0X2A80,0XEA41,

    0XEE01,0X2EC0,0X2F80,0XEF41,0X2D00,0XEDC1,0XEC81,0X2C40,

    0XE401,0X24C0,0X2580,0XE541,0X2700,0XE7C1,0XE681,0X2640,

    0x2200,0XE2C1,0XE381,0X2340,0XE101,0X21C0,0X2080,0XE041,

    0XA001,0X60C0,0X6180,0XA141,0X6300,0XA3C1,0XA281,0X6240,

    0X6600,0XA6c1,0XA781,0X6740,0XA501,0X65C0,0X6480,0XA441,

    0X6C00,0XACC1,0XAD81,0X6D40,0XAF01,0X6EC0,0X6E80,0XAE41,

    0XAA01,0X6AC0,0X6B80,0XAB41,0X6900,0XA9C1,0XA881,0X6840,

    0X7800,0XB8C1,0XB981,0X7940,0XBB01,0X7BC0,0X7A80,0XBA41,

    0XBE01,0X7EC0,0X7F80,0XBF41,0X7D00,0XBDC1,0XBC81,0X7C40,

    0XB401,0X74C0,0X7580,0XB541,0X7700,0XB7C1,0XB681,0X7640,

    0X7200,0XB2C1,0XB381,0X7340,0XB101,0X71C0,0X7080,0XB041,

    0X5000,0X90c1,0X9181,0X5140,0X9301,0X53c0,0X5280,0X9241,

    0X9601,0X56C0,0X5780,0X9741,0X5500,0X95c1,0X9481,0X5440,

    0X9C01,0X5cc0,0X5D80,0X9D41,0X5E00,0X9FC1,0X9E81,0X5E40,

    0X5A00,0X9AC1,0X9B81,0X5B40,0x9901,0x59c0,0x5880,0X9841,

    0x8801,0X4BC0,0X4980,0X8941,0X4B00,0XBBC1,0X8AB1,0X4A40,

    0X4E00,0X8EC1,0X8F81,0X4F40,0X8D01,0X4DC0,0X4C80,0X8C41,

    0X4400,0X84c1,0x8581,0X4540,0X8701,0X47C0,0X4680,0X8641,

    0x8201,0X42c0,0x4380,0X8341,0X4100,0XB1C1,0X8081,0X4040,

  };

  unsigned char nTemp;

  unsigned short usRegCRC = 0xFFFF;

  while (usDataLen--)

  {

    nTemp = * puchMsg ++ ^ usRegCRC;

    usRegCRC >> = 8;

    usRegCRC ^= usCRCTable[nTemp];

  }

  return usRegCRC;

} 
```

查表法的特点是以字节为单位进行计算，速度快，语句少，但表格会占用一定的程序空间。

- **计算法：**

计算法按位计算,适用于所有长度的数据校验,最为灵活;但由于是按位计算,其效率并不是最优的,只适用于对速度不敏感的场合。计算法的基本算法如下； 输入参数的意义:

```c
unsigned char * puchMsg;       /*要进行 CRC校验的消息* /

unsigned short usDataLen;      /*消息中的字节数*/

/*函数返回unsigned short(即 2个字节)类型的CRC值*/

unsigned short CRC16(unsigned char *puchMsg,unsigned short usDataLen)

{

  int i，j;                     /*循环变量*/

  unsigned shortusRegCRC =0xFFFF;         /*用于保存CRC值*/

  

  for(i=0;i < usDataLen;i++)            /*循环处理传输缓冲区消息*/

  {

    usRegCRC ^= * puchMsg++;             /*异或算法得到CRC值*/

    for(j=0;j<8;j++)                 /*循环处理每个 bit位*/

    {

      if (usRegCRC &0x0001)

        usRegCRC =usRegCRC >>1^0xA001;

      else

        usRegCRC >>=1;

    }

  }

  

  return usRegCRC;

}
```

下面举一个简单的例子。假设从设备地址为 1,要求读取输入寄存器地址30001的值，则RTU模式下的具体查询消息帧如下：

```c
0x01,0x04,0x00,0x00,0x00,0x01,0x31,0xCA
```

其中，0xCA31即为CRC值。因为Modbus规定发送时CRC必须低字节在前、高字节在后，因此实际的消息帧的发送顺序为0x31,0xCA。

### 5.4.7 字节序和大小端

Modbus中传输的数据，按照“大字节序”来传输，比如：

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image34.png) 

寄存器数值是0x1234，先传输0x12，再传输0x34。

在 Modbus 寄存器中,对于一个由 2字节组成的16数,在内存中存储这两个字节有两种方法:一种是将低序字节存储在起始地址为小端(Little-Endian)字节序;另一种方法是将高序字节存储在起始地称为大端(Big-Endian)字节序。Modbus 通信协议中具体规定了字节高低位发送顺序,这样就自然引出了字节序和大小端的问题。

- **什么是大端：**

  所谓大端，是指数据的低位保存在内存的高地址中，数据的高位保存在内存的低地址中。

- **什么是小端：**

  所谓小端，是指数据的低位保存在内存的低地址中，数据的高位保存在内存的高地址中。

- **为什么会有大小端：**

  计算机系统是以字节为单位的，每个地址单元都对应着1个字节，一个字节为8bit。但在C语言中除了8bit的char类型，还有16bit的short类型和32bit的long类型，还有就是对于位数大于8位的处理器，如16位或32位的处理器，由于寄存器宽度大于一个字节，那么必然存在一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式的出现。

低位字节和高位字节：好比如：123456 其中的1就是高位数字，6就是低位数字。

举一个例子，在32位数字0x12345678在内存中的表示形式为：

**1)大端模式**：

| 低地址 | ——   | ——   | 高地址 |
| ------ | ---- | ---- | ------ |
| 0x12   | 0x34 | 0x56 | 0x78   |

**2)小端模式：**

| 低地址 | ——   | ——   | 高地址 |
| ------ | ---- | ---- | ------ |
| 0x78   | 0x56 | 0x34 | 0x12   |

### 5.4.8 Modbus报文分析

在第二章中我们已经生成了一个报文，我们就拿此报文来逐步分析一下,报文如下：

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image35.png) 

我们可以看到上面报文都是循环发送的，这样看起来不太容易分析，我摘抄下来其中一组来给大家分析

**发送:**

| 从机地址 | 功能码 | 起始地址高位 | 起始地址低位 | 寄存器数量高位 | 寄存器数量低位 | CRC高位 | CRC低位 |
| -------- | ------ | ------------ | ------------ | -------------- | -------------- | ------- | ------- |
| 01       | 03     | 00           | 00           | 00             | 0A             | C5      | CD      |

**响应:**

| 从机地址 | 功能码 | 返回字节数 | 数据位 | CRC高位 | CRC低位 |
| -------- | ------ | ---------- | ------ | ------- | ------- |
| 01       | 03     | 14         | 00 42… | CF      | 10      |

这里我们就以03功能码为例来分析一下报文；

- 03发送报文格式：从机地址+功能码+加起始地址+寄存器数量+CRC校验
- 03接受报文格式：从机地址+功能码+字节数+具体数据+CRC校验

首先我们看一下发送报文：

从机地址是01，功能码03，起始地址00，寄存器数量是十六进制0A也就是10，和门设置的是一样的，我们来对对照一下我们设置的参数：

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image36.png) 

我们再来看一下接收报文：

从机地址是01，功能码03，返回字节数是十六进制14也就是返回20给字节，我们发送是个返回20个字节也是对的上的，第一个数据位是00 42 也是和我们发送的可以对上，十六机制42，也就66，我们来看一下我们之前设置的参数：

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image37.png) 

### 5.4.9 Moubus TCP 消息帧格式

#### 1.协议描述

在Modbus TCP/IP中，串行链路中的主/从设备分别演变为客户端/服务器端设备，即客户端相当于主站设备，服务器端设备相当于从设备。基于TCP/IP网络的传输特性,串行链路上一主多从的机构也演变为多客户端/多服务器端的构造模型。Modbus协议在TCP/IP上的实现是在TCP/IP层上的应用，它需要一个完整的TCP/IP栈作为支撑，Modbus TCP/IP服务器端通常使用端口502作为接收报文的端口。

下图为Moubus TCP的通讯结构：

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image38.png) 

ModbusTCP与ModbusUDP的报文格式是一样的，它们之间的区别其实就是TCP与UDP的区别，因此下面就针对ModbusTCP的协议进行分析，ModbusTCP与ModbusRtu（ModbusASCII）之间的区别如下图：

![img](http://photos.100ask.net/modbus-docs/project_one/chapter6/image39.png) 

从上图可以看出，ModbusTCP在Modbus串行通信的基础上，去除了校验（由于TCP本身就带有校验和）和设备地址（ModbusTCP弱化了设备地址，用IP地址来取代），再加上MBAP报文头（占7 bytes），下面针对MBAP进行分析说明：

| 字段名                                 | 长度  | 描述                                                         | 主站（客户端）     | 从站（服务器端）               |
| -------------------------------------- | ----- | ------------------------------------------------------------ | ------------------ | ------------------------------ |
| 事务处理标识符(Transaction Identifier) | 2字节 | Modbus 请求/应答传输过程的事务处理的识别码，可以设置为0，也可以设置为每次通讯时自动+1 | 主站（客户端）生成 | 应答时从主站（客户端）复制该值 |
| 协议标识符(Protocol Identifier)        | 2字节 | 00表示是 Modbus协议，固定值                                  | 主站（客户端）生成 | 应答时从主站（客户端）复制该值 |
| 长度(Lendgth)                          | 2字节 | 从单元标识符开始，整个PDU的数据长度，分为字节长度Hi和Lo      | 请求时生成         | 应答时重新生成                 |
| 单元标识符(Unit Identifier)            | 1字节 | 串行链路或其他总线上连接的远程从站的识别码，可以设置为从机设备的地址 | 主站（客户端）生成 | 应答时从主站（客户端）复制该值 |

**事务处理标识符：**

事务处理标识用于在查询报文与未来响应之间建立联系。因此,对 TCP/IP 连接来说，在同一时刻这个标识符必须是唯一的。有以下几种使用此标识符的方式。

例如，可以将传输标识作为一个带有计数器的简单“TCP 发送顺序号”，在每个请求发送时自动+1；也可以用作智能索引或指针，用来识别事务处理的内容，以便记忆当前的远端服务器和未处理的请求。

服务器端可接收的请求数量取决于其容量,即服务器资源量和 TCP 窗口尺同样,客户端同时启动事务处理的数量也取决于客户端的资源容量。

**单元标识符:**

在对Modbus或 Modbus+等串行链路子网中的设备进行寻址时，这个域用于路由的目的。在这种情况下,单元标识符（Unit Identifier） 携带一个远端设备的Modbus 从站地址。

如果 Modbus 服务器连接到 Modbus+或 Modbus 串行链路子网，并通过一个网桥或网关配置这个服务器的IP 地址,则 Modbus 单元标识符对识别连接到网桥或网关后的子网的从站设备是必需的。TCP 连接中的目的 IP 地址识别了网桥本身的地址,而网桥则使用 Modbus 单元标识符将请求转交给正确的从站设备。 分配给串行链路上的 Modbus 从站设备地址为 1~247(十进制),地址0作为广播地址。

对单纯的 Modbus TCP/IP 设备来说用IP 地址即可寻址 Modbus 服务器端设备，此时 Modbus 单元标识符是无用的，必须使用值0xFF 填充。当对直接连接到 TCP/IP 网络上的 Modbus 服务器寻址时,建议不要在“单元标识符”域使用有效的Modbus从站地址。

以上是MBAP报文头个字段含义的详细说明。

实际上，在 Modbus TCP/IP传输过程中，服务端(从机)返回的响应报文中同样包含 MBAP报头，除了 Length 字段外，其他字段均与客户端一致。Modbus消息由 TCP/IP 层提供,不需要像串行链路那样自己判断一帧是否结束，所有数据传输均由 TCP/IP层处理。因为底层的 TCP/IP 确保了端到端的连接，而且 TCP/IP链路层已确保传输数据的准确性,所以 Modbus TCP/IP 中已不再需要 LRC或CRC 等校验功能。

#### 2. 查询与响应报文示例

对于Modbus TCP消息帧格式，下面举例说明各部分的含义。

- 查询报文：00 00 00 00 00 06 09 03 00 04 00 01。
  - 0x06: 后续还有6字节。
  - 0x09: 单元标识符为9。
  - 0x03: 功能码 3，即读保持寄存器的值。
  - 0x00 0x04: Modbus起始地址4（即40005）。
  - 0x00 0x01: 读取寄存器个数为1。

- 响应报文：00 00 00 00 00 05 09 03 02 00 05。
  - 0x05：表示后续还有5字节。
  - 0x09：同查询报文，单元标识符。
  - 0x03：功能码，同查询报文。
  - 0x02：返回数据字节数。
  - 0x00 0x05：寄存器的值。

可见，在Modbus TCP模式下，差错校验字段已不复存在。但在某些特殊场合，例如串行Modbus协议转Modbus TCP的情况下，串行协议数据可以完整地装载到Modbus TCP的数据字段，这时CRC或LRC差错校验字段仍然存在。例如，Modbus RTU Over TCP/IP 或 Modbus ASCII Over TCP/IP等。